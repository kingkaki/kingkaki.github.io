<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content>
    <meta name="keyword" content>
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
          gadgetinspector源码浅析 - Kingkk&#39;s Blog
        
    </title>

    <link rel="canonical" href="https://www.kingkk/2020/01/gadgetinspector源码浅析/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/hux-blog.min.css">

    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css">

    <!-- Custom Fonts -->
    <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Kingkk&#39;s Blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/archives/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    
<!-- Image to hack wechat -->
<!-- <img src="https://www.kingkk/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="{{ site.baseurl }}/{% if page.header-img %}{{ page.header-img }}{% else %}{{ site.header-img }}{% endif %}" width="0" height="0"> -->

<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        background-image: url('/img/home-bg.jpg')
    }
</style>
<header class="intro-header" >
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                          <a class="tag" href="/tags/#java" title="java">java</a>
                        
                          <a class="tag" href="/tags/#语法分析" title="语法分析">语法分析</a>
                        
                    </div>
                    <h1>gadgetinspector源码浅析</h1>
                    <h2 class="subheading"></h2>
                    <span class="meta">
                        Posted by kingkk on
                        2020-01-31
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前在实习的时候在先知上看到 @threedr3am 师傅在先知上发了两篇关于gadgetinspector分析的文章  <a href="https://xz.aliyun.com/t/7058" target="_blank" rel="noopener">https://xz.aliyun.com/t/7058</a>  ，确实写的很好。关于gadgetinspector这款工具之前就有注意到过，但是没有具体去看。</p>
<p>由于之前有过想法做类似的东西，所以对这个也很感兴趣，但是由于一些子/父类、接口/实现类之间的处理有些头疼，于是做了个简易版，挖了个新的gadget之后便没后文了。正好最近疫情严重，在家都快呆发霉了，便想来看下这款工具是如何做这些处理操作的。</p>
<h1 id="整体概览"><a href="#整体概览" class="headerlink" title="整体概览"></a>整体概览</h1><p>整个程序的入口是<code>GadgetInspector</code>类，大致看一下main函数以及跑一下整个程序，就可以看到几个比较关键的类，以及以文件形式存储在本地的<code>.dat</code>备份文件。</p>
<ul>
<li><code>MethodDiscovery</code> 用以收集类/方法以及继承/实现关系，分别对应<code>classes.dat</code>、<code>methods.dat</code>、<code>inheritanceMap.dat</code></li>
<li><code>PassthroughDiscovery</code> 用以发现函数返回值与传参之间的污点关系，对应<code>passthrough.dat</code></li>
<li><code>CallGraphDiscovery</code> 用以发现函数之间的调用关系，对应<code>callgraph.dat</code></li>
<li><code>SourceDiscovery</code>  用以发现所有source点，对应<code>sources.dat</code></li>
<li><code>GadgetChainDiscovery</code> 前面的工作都算信息搜集的步骤，有了前面的信息之后，就可以真正开始挖掘gadget了</li>
</ul>
<h1 id="启动入口"><a href="#启动入口" class="headerlink" title="启动入口"></a>启动入口</h1><p>一开始的工作其实很简单，主要就是参数的绑定和一些日志之类的配置</p>
<p>一开始就是参数判断，输出用法，然后配置日志信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (args.length == <span class="number">0</span>) &#123;</span><br><span class="line">    printUsage();</span><br><span class="line">    System.exit(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置log4j用于输出日志</span></span><br><span class="line">configureLogging();</span><br></pre></td></tr></table></figure>
<p>之后就是根据命令行传参设置<code>resume</code>、<code>config</code>、<code>boot</code>几个参数，分别对应是否删除bat文件，gadget类型，和是否是springboot的jar包。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> resume = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//fuzz类型，默认java原生序列化</span></span><br><span class="line">GIConfig config = ConfigRepository.getConfig(<span class="string">"jserial"</span>);</span><br><span class="line"><span class="keyword">boolean</span> boot = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> argIndex = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (argIndex &lt; args.length) &#123;</span><br><span class="line">    String arg = args[argIndex];</span><br><span class="line">    <span class="keyword">if</span> (!arg.startsWith(<span class="string">"--"</span>)) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arg.equals(<span class="string">"--resume"</span>)) &#123;</span><br><span class="line">        <span class="comment">//不删除dat文件</span></span><br><span class="line">        resume = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg.equals(<span class="string">"--config"</span>)) &#123;</span><br><span class="line">        <span class="comment">//--config参数指定fuzz类型</span></span><br><span class="line">        config = ConfigRepository.getConfig(args[++argIndex]);</span><br><span class="line">        <span class="keyword">if</span> (config == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid config name: "</span> + args[argIndex]);</span><br><span class="line">        &#125;</span><br><span class="line">        giConfig = config;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arg.equals(<span class="string">"--boot"</span>)) &#123;</span><br><span class="line">        <span class="comment">// spring boot</span></span><br><span class="line">        boot = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unexpected argument: "</span> + arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    argIndex += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后根据普通jar包、spring-boot jar包、war包载入对应字节码，返回对应的URLClassloader。具体细节就不跟进看了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ClassLoader classLoader;</span><br><span class="line"><span class="comment">//程序参数的最后一部分，即最后一个具有前缀--的参数（例：--resume）后</span></span><br><span class="line"><span class="comment">// 对指定文件根据war、spring-boot jar、普通jar包的方式载入对于字节码文件，并返回URLClassLoader</span></span><br><span class="line"><span class="keyword">if</span> (args.length == argIndex + <span class="number">1</span> &amp;&amp; args[argIndex].toLowerCase().endsWith(<span class="string">".war"</span>)) &#123;</span><br><span class="line">    <span class="comment">//加载war文件</span></span><br><span class="line">    Path path = Paths.get(args[argIndex]);</span><br><span class="line">    LOGGER.info(<span class="string">"Using WAR classpath: "</span> + path);</span><br><span class="line">    <span class="comment">//实现为URLClassLoader，加载war包下的WEB-INF/lib和WEB-INF/classes</span></span><br><span class="line">    classLoader = Util.getWarClassLoader(path);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (args.length == argIndex + <span class="number">1</span> &amp;&amp; args[argIndex].toLowerCase().endsWith(<span class="string">".jar"</span>) &amp;&amp; boot) &#123;</span><br><span class="line">    Path path = Paths.get(args[argIndex]);</span><br><span class="line">    LOGGER.info(<span class="string">"Using JAR classpath: "</span> + path);</span><br><span class="line">    <span class="comment">//实现为URLClassLoader，加载jar包下的BOOT-INF/lib和BOOT-INF/classes</span></span><br><span class="line">    classLoader = Util.getJarAndLibClassLoader(path);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//加载jar文件，java命令后部，可配置多个</span></span><br><span class="line">    <span class="keyword">final</span> Path[] jarPaths = <span class="keyword">new</span> Path[args.length - argIndex];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length - argIndex; i++) &#123;</span><br><span class="line">        Path path = Paths.get(args[argIndex + i]).toAbsolutePath();</span><br><span class="line">        <span class="keyword">if</span> (!Files.exists(path)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid jar path: "</span> + path);</span><br><span class="line">        &#125;</span><br><span class="line">        jarPaths[i] = path;</span><br><span class="line">    &#125;</span><br><span class="line">    LOGGER.info(<span class="string">"Using classpath: "</span> + Arrays.toString(jarPaths));</span><br><span class="line">    <span class="comment">//实现为URLClassLoader，加载所有指定的jar</span></span><br><span class="line">    classLoader = Util.getJarClassLoader(jarPaths);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后自己封装了一个<code>ClassResourceEnumerator</code>classloader,具有两个方法</p>
<ul>
<li><code>getRuntimeClasses</code>获取rt.jar的所有class</li>
<li><code>getAllClasses</code>获取rt.jar以及classLoader加载的class</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ClassResourceEnumerator classResourceEnumerator = <span class="keyword">new</span> ClassResourceEnumerator(classLoader);</span><br></pre></td></tr></table></figure>
<p>之后就是根据resume参数来决定是否删除之前留下的备份文件，相当于一个缓存的作用，需要时直接从备份文件中取相应信息即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除所有的dat文件</span></span><br><span class="line"><span class="keyword">if</span> (!resume) &#123;</span><br><span class="line">    <span class="comment">// Delete all existing dat files</span></span><br><span class="line">    LOGGER.info(<span class="string">"Deleting stale data..."</span>);</span><br><span class="line">    <span class="keyword">for</span> (String datFile : Arrays.asList(<span class="string">"classes.dat"</span>, <span class="string">"methods.dat"</span>, <span class="string">"inheritanceMap.dat"</span>,</span><br><span class="line">                                        <span class="string">"passthrough.dat"</span>, <span class="string">"callgraph.dat"</span>, <span class="string">"sources.dat"</span>, <span class="string">"methodimpl.dat"</span>)) &#123;</span><br><span class="line">        <span class="keyword">final</span> Path path = Paths.get(datFile);</span><br><span class="line">        <span class="keyword">if</span> (Files.exists(path)) &#123;</span><br><span class="line">            Files.delete(path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后就能看到分出了5个明显的block，也分别对应了之前整体概览里提到的五个类所做的事情。</p>
<p>前四个主要都是信息搜集的工作，也正是要处理好这些数据流、方法重写等问题，才能更好也更全面的找gadget。</p>
<h1 id="MethodDiscovery"><a href="#MethodDiscovery" class="headerlink" title="MethodDiscovery"></a>MethodDiscovery</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!Files.exists(Paths.get(<span class="string">"classes.dat"</span>)) || !Files.exists(Paths.get(<span class="string">"methods.dat"</span>))</span><br><span class="line">    || !Files.exists(Paths.get(<span class="string">"inheritanceMap.dat"</span>))) &#123;</span><br><span class="line">    LOGGER.info(<span class="string">"Running method discovery..."</span>);</span><br><span class="line">    MethodDiscovery methodDiscovery = <span class="keyword">new</span> MethodDiscovery();</span><br><span class="line">    methodDiscovery.discover(classResourceEnumerator);</span><br><span class="line">    <span class="comment">//保存了类信息、方法信息、继承实现信息</span></span><br><span class="line">    methodDiscovery.save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要看<code>discover</code>方法，是如何获取类、方法以及继承/实现信息的。</p>
<h2 id="discover"><a href="#discover" class="headerlink" title="discover"></a>discover</h2><p>由于提供的是字节码信息，则需要一个字节码操作工具，这里用的是asm，算是一个比较底层且全的字节码操作库，由于个人不是特别熟，只能浅显的看一下。</p>
<p>看到在<code>discover</code>方法中获取了所有的类，并通过<code>MethodDiscoveryClassVisitor</code>去记录类和类方法信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (ClassResourceEnumerator.ClassResource classResource : classResourceEnumerator.getAllClasses()) &#123;</span><br><span class="line">    <span class="keyword">try</span> (InputStream in = classResource.getInputStream()) &#123;</span><br><span class="line">        ClassReader cr = <span class="keyword">new</span> ClassReader(in);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//使用asm的ClassVisitor、MethodVisitor，利用观察模式去扫描所有的class和method并记录</span></span><br><span class="line">            cr.accept(<span class="keyword">new</span> MethodDiscoveryClassVisitor(), ClassReader.EXPAND_FRAMES);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">"Exception analyzing: "</span> + classResource.getName(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟进可以看到<code>MethodDiscoveryClassVisitor</code>继承了<code>ClassVisitor</code>，他会以一种观察者模式的方式去扫描所有信息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodDiscoveryClassVisitor</span> <span class="keyword">extends</span> <span class="title">ClassVisitor</span></span></span><br></pre></td></tr></table></figure>
<p><code>MethodDiscoveryClassVisitor</code>通过重载了类的一些方法之后，就可以在扫描不同部分信息时，增加一些自己的操作。</p>
<p>这里最先被调用的是<code>visit</code>方法，里面会传入版本号，类名，签名，父类名，实现接口等信息，这这里主要对他们做了记录，并保存在自己的成员变量中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span> <span class="params">( <span class="keyword">int</span> version, <span class="keyword">int</span> access, String name, String signature, String superName, String[]interfaces)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.superName = superName;</span><br><span class="line">    <span class="keyword">this</span>.interfaces = interfaces;</span><br><span class="line">    <span class="keyword">this</span>.isInterface = (access &amp; Opcodes.ACC_INTERFACE) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.members = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">this</span>.classHandle = <span class="keyword">new</span> ClassReference.Handle(name);<span class="comment">//类名</span></span><br><span class="line">    annotations = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">super</span>.visit(version, access, name, signature, superName, interfaces);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后访问到注解信息时，也会将注解信息记录在成员变量中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AnnotationVisitor <span class="title">visitAnnotation</span><span class="params">(String descriptor, <span class="keyword">boolean</span> visible)</span> </span>&#123;</span><br><span class="line">    annotations.add(descriptor);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.visitAnnotation(descriptor, visible);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>访问成员变量时，记录修饰符，变量名信息，并封装成定义好的<code>ClassReference</code></p>
<p>访问时会跳过静态变量，因为这一部分变量应该是全局性的，无法通过反序列化等方式控制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> FieldVisitor <span class="title">visitField</span><span class="params">(<span class="keyword">int</span> access, String name, String desc,</span></span></span><br><span class="line"><span class="function"><span class="params">                               String signature, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((access &amp; Opcodes.ACC_STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">        Type type = Type.getType(desc);</span><br><span class="line">        String typeName;</span><br><span class="line">        <span class="keyword">if</span> (type.getSort() == Type.OBJECT || type.getSort() == Type.ARRAY) &#123;</span><br><span class="line">            typeName = type.getInternalName();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            typeName = type.getDescriptor();</span><br><span class="line">        &#125;</span><br><span class="line">        members.add(<span class="keyword">new</span> ClassReference.Member(name, access, <span class="keyword">new</span> ClassReference.Handle(typeName)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.visitField(access, name, desc, signature, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>访问方法时也是同理，记录类名、方法名、签名、以及是否是静态等信息封装成<code>MethodReference</code>的形式存储</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MethodVisitor <span class="title">visitMethod</span><span class="params">(<span class="keyword">int</span> access, String name, String desc, String signature, String[] exceptions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isStatic = (access &amp; Opcodes.ACC_STATIC) != <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//找到一个方法，添加到缓存</span></span><br><span class="line">    discoveredMethods.add(<span class="keyword">new</span> MethodReference(</span><br><span class="line">        classHandle,<span class="comment">//类名</span></span><br><span class="line">        name,</span><br><span class="line">        desc,</span><br><span class="line">        isStatic));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.visitMethod(access, name, desc, signature, exceptions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当一个类访问结束时就会调用<code>visitEnd</code>，做一些类似析构函数的工作</p>
<p>这里就是封装成<code>ClassReference</code>的方式存储类信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ClassReference classReference = <span class="keyword">new</span> ClassReference(</span><br><span class="line">        name,</span><br><span class="line">        superName,</span><br><span class="line">        interfaces,</span><br><span class="line">        isInterface,</span><br><span class="line">        members.toArray(<span class="keyword">new</span> ClassReference.Member[members.size()]),</span><br><span class="line">        annotations);<span class="comment">//把所有找到的字段封装</span></span><br><span class="line">    <span class="comment">//找到一个方法遍历完成后，添加类到缓存</span></span><br><span class="line">    discoveredClasses.add(classReference);</span><br><span class="line">    <span class="keyword">super</span>.visitEnd();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当这些工作都做完之后，类信息/方法信息/字段信息等就算搜集完成了</p>
<h2 id="save"><a href="#save" class="headerlink" title="save"></a>save</h2><p>之后就是比简单的save工作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//保存和读取使用Factory实现</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//classes.dat数据格式：</span></span><br><span class="line">    <span class="comment">//类名(例：java/lang/String) 父类 接口A,接口B,接口C 是否接口 字段1!字段1access!字段1类型!字段2!字段2access!字段1类型</span></span><br><span class="line">    DataLoader.saveData(Paths.get(<span class="string">"classes.dat"</span>), <span class="keyword">new</span> ClassReference.Factory(), discoveredClasses);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//methods.dat数据格式：</span></span><br><span class="line">    <span class="comment">//类名 方法名 方法描述 是否静态方法</span></span><br><span class="line">    DataLoader.saveData(Paths.get(<span class="string">"methods.dat"</span>), <span class="keyword">new</span> MethodReference.Factory(), discoveredMethods);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//形成 类名(ClassReference.Handle)-&gt;类(ClassReference) 的映射关系</span></span><br><span class="line">    Map&lt;ClassReference.Handle, ClassReference&gt; classMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (ClassReference clazz : discoveredClasses) &#123;</span><br><span class="line">        classMap.put(clazz.getHandle(), clazz);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保存classes.dat和methods.dat的同时，对所有的class进行递归整合，得到集合&#123;class:[subclass]&#125;，</span></span><br><span class="line">    <span class="comment">// class为subclass父类、超类或实现的接口类，保存至inheritanceMap.dat</span></span><br><span class="line">    InheritanceDeriver.derive(classMap).save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ClassReference.Factory</code>和<code>MethodReference.Factory()</code>都定义了对应的存储方式</p>
<ul>
<li>classes.dat  <code>类名 | 父类名 | 所有接口 | 是否是接口 | 成员变量</code></li>
<li>methods.dat <code>类名 | 方法名 | 方法描述信息 | 是否是静态方法</code></li>
</ul>
<p>然后在<code>InheritanceDeriver.derive(classMap)</code>根据类信息，就可以获取到所有的继承/实现关系。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InheritanceMap <span class="title">derive</span><span class="params">(Map&lt;ClassReference.Handle, ClassReference&gt; classMap)</span> </span>&#123;</span><br><span class="line">    LOGGER.debug(<span class="string">"Calculating inheritance for "</span> + (classMap.size()) + <span class="string">" classes..."</span>);</span><br><span class="line">    Map&lt;ClassReference.Handle, Set&lt;ClassReference.Handle&gt;&gt; implicitInheritance = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">//遍历所有类</span></span><br><span class="line">    <span class="keyword">for</span> (ClassReference classReference : classMap.values()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (implicitInheritance.containsKey(classReference.getHandle())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already derived implicit classes for "</span> + classReference.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;ClassReference.Handle&gt; allParents = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取classReference的所有父类、超类、接口类</span></span><br><span class="line">        getAllParents(classReference, classMap, allParents);</span><br><span class="line">        <span class="comment">//添加缓存：类名 -&gt; 所有的父类、超类、接口类</span></span><br><span class="line">        implicitInheritance.put(classReference.getHandle(), allParents);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//InheritanceMap翻转集合，转换为&#123;class:[subclass]&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> InheritanceMap(implicitInheritance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到遍历了所有的类，然后再通过<code>getAllParents</code>以递归的方式获取所有的父类和实现类</p>
<p>然后最后翻转转换成<code>父类 -&gt; [子类1、子类2...]</code>的对应关系</p>
<p>然后保存到<code>inheritanceMap.dat</code>中</p>
<p>这样，类信息/方法信息/继承实现关系的信息搜集就完成了。</p>
<h1 id="PassthroughDiscovery"><a href="#PassthroughDiscovery" class="headerlink" title="PassthroughDiscovery"></a>PassthroughDiscovery</h1><p>主要用以发现函数返回值与传参之间的污点关系，个人感觉是工作量最大的一个部分，因为不仅仅是信息搜集，还要做污点的信息判断，以及方法间的变量关联。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!Files.exists(Paths.get(<span class="string">"passthrough.dat"</span>))) &#123;</span><br><span class="line">    LOGGER.info(<span class="string">"Analyzing methods for passthrough dataflow..."</span>);</span><br><span class="line">    PassthroughDiscovery passthroughDiscovery = <span class="keyword">new</span> PassthroughDiscovery();</span><br><span class="line">    passthroughDiscovery.discover(classResourceEnumerator, config);</span><br><span class="line">    passthroughDiscovery.save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和之前的过程类似，也是分为<code>discover</code>发现和<code>save</code>保存的两个过程。</p>
<h2 id="discover-1"><a href="#discover-1" class="headerlink" title="discover"></a>discover</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载文件记录的所有方法信息</span></span><br><span class="line">Map&lt;MethodReference.Handle, MethodReference&gt; methodMap = DataLoader.loadMethods();</span><br><span class="line"><span class="comment">//加载文件记录的所有类信息</span></span><br><span class="line">Map&lt;ClassReference.Handle, ClassReference&gt; classMap = DataLoader.loadClasses();</span><br><span class="line"><span class="comment">//加载文件记录的所有类继承、实现关联信息</span></span><br><span class="line">InheritanceMap inheritanceMap = InheritanceMap.load();</span><br><span class="line"></span><br><span class="line"><span class="comment">//搜索方法间的调用关系，缓存至methodCalls集合，返回 类名-&gt;类资源 映射集合</span></span><br><span class="line">Map&lt;String, ClassResourceEnumerator.ClassResource&gt; classResourceByName = discoverMethodCalls(classResourceEnumerator);</span><br><span class="line"><span class="comment">//对方法调用关系进行字典排序</span></span><br><span class="line">List&lt;MethodReference.Handle&gt; sortedMethods = topologicallySortMethodCalls();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* classResourceByName：类资源集合</span></span><br><span class="line"><span class="comment">* classMap：类信息集合</span></span><br><span class="line"><span class="comment">* inheritanceMap：继承、实现关系集合</span></span><br><span class="line"><span class="comment">* sortedMethods：方法集合</span></span><br><span class="line"><span class="comment">* SerializableDecider：决策者</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">passthroughDataflow = calculatePassthroughDataflow(classResourceByName, classMap, inheritanceMap, sortedMethods, config.getSerializableDecider(methodMap, inheritanceMap));</span><br></pre></td></tr></table></figure>
<p>一开始就是将<code>MethodDiscovery</code>收集到的信息加载进来以供分析。</p>
<p><code>discoverMethodCalls</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, ClassResourceEnumerator.ClassResource&gt; discoverMethodCalls(<span class="keyword">final</span> ClassResourceEnumerator classResourceEnumerator) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    Map&lt;String, ClassResourceEnumerator.ClassResource&gt; classResourcesByName = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (ClassResourceEnumerator.ClassResource classResource : classResourceEnumerator.getAllClasses()) &#123;</span><br><span class="line">        <span class="keyword">try</span> (InputStream in = classResource.getInputStream()) &#123;</span><br><span class="line">            ClassReader cr = <span class="keyword">new</span> ClassReader(in);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                MethodCallDiscoveryClassVisitor visitor = <span class="keyword">new</span> MethodCallDiscoveryClassVisitor(Opcodes.ASM6);</span><br><span class="line">                cr.accept(visitor, ClassReader.EXPAND_FRAMES);</span><br><span class="line">                classResourcesByName.put(visitor.getName(), classResource);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                LOGGER.error(<span class="string">"Error analyzing: "</span> + classResource.getName(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> classResourcesByName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和之前一样，重载了<code>ClassVisitor</code>，重点看重载的<code>visitMethod</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MethodVisitor <span class="title">visitMethod</span><span class="params">(<span class="keyword">int</span> access, String name, String desc,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 String signature, String[] exceptions)</span> </span>&#123;</span><br><span class="line">    MethodVisitor mv = <span class="keyword">super</span>.visitMethod(access, name, desc, signature, exceptions);</span><br><span class="line">    <span class="comment">//在visit每个method的时候，创建MethodVisitor对method进行观察</span></span><br><span class="line">    MethodCallDiscoveryMethodVisitor modelGeneratorMethodVisitor = <span class="keyword">new</span> MethodCallDiscoveryMethodVisitor(</span><br><span class="line">        api, mv, <span class="keyword">this</span>.name, name, desc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JSRInlinerAdapter(modelGeneratorMethodVisitor, access, name, desc, signature, exceptions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里对每个method进行观察</p>
<p><code>MethodCallDiscoveryMethodVisitor</code>重载了<code>MethodVisitor</code>，可以看出是一个方法观察者</p>
<p>和<code>ClassVisitor</code>类似，可以通过重写方法，来在观察至指定位置时添加自定义的功能。</p>
<p>在初始化的时候，往<code>methodCalls</code>中添加一个<code>method -&gt; calledMethods</code>的键值对，也就是获取方法和方法中调用的方法的对应值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MethodCallDiscoveryMethodVisitor</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> api, <span class="keyword">final</span> MethodVisitor mv,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">final</span> String owner, String name, String desc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(api, mv);</span><br><span class="line">    <span class="comment">//创建calledMethod收集调用到的method，最后形成集合&#123;&#123;sourceClass,sourceMethod&#125;:[&#123;targetClass,targetMethod&#125;]&#125;</span></span><br><span class="line">    <span class="keyword">this</span>.calledMethods = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    methodCalls.put(<span class="keyword">new</span> MethodReference.Handle(<span class="keyword">new</span> ClassReference.Handle(owner), name, desc), calledMethods);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>真正收集方法中调用的方法的部分则是在<code>visitMethodInsn</code>，这部分则是在method中调用其他方法时，会被触发的逻辑</p>
<p>里面有被调用方法的方法名、所属类、函数前面等信息，只要将这些信息存放到<code>calledMethods</code>中即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitMethodInsn</span><span class="params">(<span class="keyword">int</span> opcode, String owner, String name, String desc, <span class="keyword">boolean</span> itf)</span> </span>&#123;</span><br><span class="line">    calledMethods.add(<span class="keyword">new</span> MethodReference.Handle(<span class="keyword">new</span> ClassReference.Handle(owner), name, desc));</span><br><span class="line">    <span class="keyword">super</span>.visitMethodInsn(opcode, owner, name, desc, itf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，方法和方法中调用的函数的对应关系都获取到了</p>
<p>最后<code>discoverMethodCalls</code>返回了类名和资源文件的对应关系。</p>
<p>再后面就是对methods进行了拓扑排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;MethodReference.Handle&gt; sortedMethods = topologicallySortMethodCalls();</span><br></pre></td></tr></table></figure>
<p>这里说实话一开始我怎么都看不懂这里的排序是干什么用的，为什么返回的是一个List，排序的意义又是什么呢？</p>
<p>最后百度了下发现吃了没文化的亏。 <a href="https://baike.baidu.com/item/拓扑排序/5223807" target="_blank" rel="noopener">https://baike.baidu.com/item/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/5223807</a> </p>
<blockquote>
<p>拓扑排序常用来确定一个依赖关系集中，事物发生的顺序。例如，在日常工作中，可能会将项目拆分成A、B、C、D四个子部分来完成，但A依赖于B和D，C依赖于D。为了计算这个项目进行的顺序，可对这个关系集进行拓扑排序，得出一个线性的序列，则排在前面的任务就是需要先完成的任务。</p>
<p>注意：这里得到的排序并不是唯一的！就好像你早上穿衣服可以先穿上衣也可以先穿裤子，只要里面的衣服在外面的衣服之前穿就行。</p>
</blockquote>
<p>因为我们判断一个函数是否可传递污点，主要是判断传参和返回值之间的关系，当中间经过一些其他函数时，就要跟进去判断那个函数的污点传递性。为了避免多次判断一些基础函数的传递性时，就可以对其进行拓扑排序。先将基础函数的传递性判断完毕，再判断上层调用函数的传递性，避免不必要的多次判断。（当然应该也可以用缓存的方式，缓存下判断过程中判断过的函数）</p>
<p>由于普通的拓扑排序是建立于有向无环图的基础上的，但是代码间的调用自然会呈现环状。这里对其做了一些处理，感觉seebug的这篇文章对这部分做了很形象的解释，估计一看就懂。 <a href="https://paper.seebug.org/1034/#step2-passthrough" target="_blank" rel="noopener">https://paper.seebug.org/1034/#step2-passthrough</a> </p>
<p>至于具体的代码也就不具体分析了，也就是前面形象解释的具体实现。</p>
<p>之后回到检测的逻辑，就可以开始真正的对每个函数进行污点传递性的判断了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* classResourceByName：类资源集合</span></span><br><span class="line"><span class="comment">* classMap：类信息集合</span></span><br><span class="line"><span class="comment">* inheritanceMap：继承、实现关系集合</span></span><br><span class="line"><span class="comment">* sortedMethods：方法集合</span></span><br><span class="line"><span class="comment">* SerializableDecider：决策者</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">final</span> Map&lt;MethodReference.Handle, Set&lt;Integer&gt;&gt; passthroughDataflow = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">//遍历所有方法，然后asm观察所属类，经过前面DFS的排序，调用链最末端的方法在最前面</span></span><br><span class="line"><span class="keyword">for</span> (MethodReference.Handle method : sortedMethods) &#123;</span><br><span class="line">    <span class="comment">//跳过static静态初始化代码</span></span><br><span class="line">    <span class="keyword">if</span> (method.getName().equals(<span class="string">"&lt;clinit&gt;"</span>)) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取所属类进行观察</span></span><br><span class="line">    ClassResourceEnumerator.ClassResource classResource = classResourceByName.get(method.getClassReference().getName());</span><br><span class="line">    <span class="keyword">try</span> (InputStream inputStream = classResource.getInputStream()) &#123;</span><br><span class="line">        ClassReader cr = <span class="keyword">new</span> ClassReader(inputStream);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            PassthroughDataflowClassVisitor cv = <span class="keyword">new</span> PassthroughDataflowClassVisitor(classMap, inheritanceMap, passthroughDataflow, serializableDecider, Opcodes.ASM6, method);</span><br><span class="line">            cr.accept(cv, ClassReader.EXPAND_FRAMES);</span><br><span class="line">            passthroughDataflow.put(method, cv.getReturnTaint());<span class="comment">//缓存方法返回值与哪个参数有关系</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">"Exception analyzing "</span> + method.getClassReference().getName(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        LOGGER.error(<span class="string">"Unable to analyze "</span> + method.getClassReference().getName(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> passthroughDataflow;</span><br></pre></td></tr></table></figure>
<p>根据数据类型就可以看出<code>passthroughDataflow</code>获取到的应该是一个函数与会影响返回值的参数index</p>
<p>遍历之前拓扑排序后的函数列表，并且跳过静态初始化方法，和之前一样重载了一个类观察者</p>
<p>重写了<code>visitMethod</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MethodVisitor <span class="title">visitMethod</span><span class="params">(<span class="keyword">int</span> access, String name, String desc,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 String signature, String[] exceptions)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//不是目标观察的method需要跳过，上一步得到的method都是有调用关系的method才需要数据流分析</span></span><br><span class="line">    <span class="keyword">if</span> (!name.equals(methodToVisit.getName()) || !desc.equals(methodToVisit.getDesc())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (passthroughDataflowMethodVisitor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Constructing passthroughDataflowMethodVisitor twice!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对method进行观察</span></span><br><span class="line">    MethodVisitor mv = <span class="keyword">super</span>.visitMethod(access, name, desc, signature, exceptions);</span><br><span class="line">    passthroughDataflowMethodVisitor = <span class="keyword">new</span> PassthroughDataflowMethodVisitor(</span><br><span class="line">        classMap, inheritanceMap, <span class="keyword">this</span>.passthroughDataflow, serializableDecider,</span><br><span class="line">        api, mv, <span class="keyword">this</span>.name, access, name, desc, signature, exceptions);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JSRInlinerAdapter(passthroughDataflowMethodVisitor, access, name, desc, signature, exceptions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面是一些筛选工作，只挑出当前指定method进行观察。然后对method进行了<code>PassthroughDataflowMethodVisitor</code>的观察模式。这里面的逻辑也就是比较重点的一部分。</p>
<p>这里要注意到<code>PassthroughDataflowMethodVisitor</code>继承的是<code>TaintTrackingMethodVisitor</code>类</p>
<p>下面的操作涉及到很多字节码、JVM指令相关，很多东西也不太了解，就只能稍微讲解下我的理解。</p>
<p><code>TaintTrackingMethodVisitor</code>中定义了一个全局变量<code>PASSTHROUGH_DATAFLOW</code>，个人理解应该就是<code>propagator</code>也就是污点传播函数。哪些函数的参数传入会传播污点信息，这里主要就是做了这样一个标记。</p>
<p>一些栈帧操作先跳过不看（因为具体我也不太了解），可以重点关注下<code>visitMethodInsn</code>这个对函数内部访问时调用的函数。</p>
<p>一开始应该是对静态调用函数的判断，进而做一些操作，因为静态函数的参数0不是this。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Type[] argTypes = Type.getArgumentTypes(desc);</span><br><span class="line"><span class="keyword">if</span> (opcode != Opcodes.INVOKESTATIC) &#123;</span><br><span class="line">    Type[] extendedArgTypes = <span class="keyword">new</span> Type[argTypes.length+<span class="number">1</span>];</span><br><span class="line">    System.arraycopy(argTypes, <span class="number">0</span>, extendedArgTypes, <span class="number">1</span>, argTypes.length);</span><br><span class="line">    extendedArgTypes[<span class="number">0</span>] = Type.getObjectType(owner);</span><br><span class="line">    argTypes = extendedArgTypes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后面switch的部分才是重点</p>
<p>可以看到对四种invoke方法都做了同一个操作，对JVM函数操作熟悉点的就可以知道这里应该漏了一个动态调用<code>invokedynamic</code>，这也是在项目的介绍中介绍了为什么对一些动态调用操作无法检查的原因。</p>
<p>一开始构造了污染参数的集合，然后通过一些方式来判断污点的传播性。</p>
<ul>
<li>如果是构造方法，则污染生成的对象</li>
<li>对<code>java/io/ObjectInputStream</code>的<code>defaultReadObject</code>做了特殊处理，污染thiss</li>
<li>如果是内置的<code>propagator</code>函数，则根据定义的参数index来判断是否可污染</li>
<li>根据之前拓扑信息排序，可以直接获取被调用函数的污点传播信息</li>
<li>如果不是静态调用 &amp;&amp; 第一个参数是object &amp;&amp; 是集合类型（继承了<code>java/util/Collection</code>或者<code>java/util/Map</code>）的，则污染所有的存储元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">    <span class="keyword">case</span> Opcodes.INVOKESTATIC:</span><br><span class="line">    <span class="keyword">case</span> Opcodes.INVOKEVIRTUAL:</span><br><span class="line">    <span class="keyword">case</span> Opcodes.INVOKESPECIAL:</span><br><span class="line">    <span class="keyword">case</span> Opcodes.INVOKEINTERFACE:</span><br><span class="line">        <span class="comment">//todo 1 构造污染参数集合，方法调用前先把操作数入栈</span></span><br><span class="line">        <span class="keyword">final</span> List&lt;Set&lt;T&gt;&gt; argTaint = <span class="keyword">new</span> ArrayList&lt;Set&lt;T&gt;&gt;(argTypes.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; argTypes.length; i++) &#123;</span><br><span class="line">            argTaint.add(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; argTypes.length; i++) &#123;</span><br><span class="line">            Type argType = argTypes[i];</span><br><span class="line">            <span class="keyword">if</span> (argType.getSize() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; argType.getSize() - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                    pop();</span><br><span class="line">                &#125;</span><br><span class="line">                argTaint.set(argTypes.length - <span class="number">1</span> - i, pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//todo 2 构造方法的调用，意味参数0可以污染返回值</span></span><br><span class="line">        Set&lt;T&gt; resultTaint;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">"&lt;init&gt;"</span>)) &#123;</span><br><span class="line">            <span class="comment">//如果被调用的方法是构造方法，则直接通过对象污染</span></span><br><span class="line">            <span class="comment">// Pass result taint through to original taint set; the initialized object is directly tainted by</span></span><br><span class="line">            <span class="comment">// parameters</span></span><br><span class="line">            resultTaint = argTaint.get(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resultTaint = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//污染例外关联，不通过参数关联</span></span><br><span class="line">        <span class="comment">// If calling defaultReadObject on a tainted ObjectInputStream, that taint passes to "this"</span></span><br><span class="line">        <span class="keyword">if</span> (owner.equals(<span class="string">"java/io/ObjectInputStream"</span>) &amp;&amp; name.equals(<span class="string">"defaultReadObject"</span>) &amp;&amp; desc.equals(<span class="string">"()V"</span>)) &#123;</span><br><span class="line">            savedVariableState.localVars.get(<span class="number">0</span>).addAll(argTaint.get(<span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//todo 3 在名单内的方法的调用，已预置哪个参数可以污染返回值</span></span><br><span class="line">        <span class="comment">//例外，污染白名单，固定哪个参数可以污染下去</span></span><br><span class="line">        <span class="keyword">for</span> (Object[] passthrough : PASSTHROUGH_DATAFLOW) &#123;</span><br><span class="line">            <span class="keyword">if</span> (passthrough[<span class="number">0</span>].equals(owner) &amp;&amp; passthrough[<span class="number">1</span>].equals(name) &amp;&amp; passthrough[<span class="number">2</span>].equals(desc)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt; passthrough.length; i++) &#123;</span><br><span class="line">                    resultTaint.addAll(argTaint.get((Integer)passthrough[i]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//todo 4 前面已做逆拓扑，调用链最末端最先被visit，因此，调用到的方法必然已被visit分析过</span></span><br><span class="line">        <span class="comment">//通过PassthroughDiscovery发现的参数和返回值污染</span></span><br><span class="line">        <span class="keyword">if</span> (passthroughDataflow != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Set&lt;Integer&gt; passthroughArgs = passthroughDataflow.get(methodHandle);</span><br><span class="line">            <span class="keyword">if</span> (passthroughArgs != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> arg : passthroughArgs) &#123;</span><br><span class="line">                    resultTaint.addAll(argTaint.get(arg));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Heuristic; if the object implements java.util.Collection or java.util.Map, assume any method accepting an object</span></span><br><span class="line">        <span class="comment">// taints the collection. Assume that any method returning an object returns the taint of the collection.</span></span><br><span class="line">        <span class="keyword">if</span> (opcode != Opcodes.INVOKESTATIC &amp;&amp; argTypes[<span class="number">0</span>].getSort() == Type.OBJECT) &#123;</span><br><span class="line">            <span class="comment">//获取被调用函数的所有基类</span></span><br><span class="line">            Set&lt;ClassReference.Handle&gt; parents = inheritanceMap.getSuperClasses(<span class="keyword">new</span> ClassReference.Handle(argTypes[<span class="number">0</span>].getClassName().replace(<span class="string">'.'</span>, <span class="string">'/'</span>)));</span><br><span class="line">            <span class="keyword">if</span> (parents != <span class="keyword">null</span> &amp;&amp; (parents.contains(<span class="keyword">new</span> ClassReference.Handle(<span class="string">"java/util/Collection"</span>)) ||</span><br><span class="line">                                    parents.contains(<span class="keyword">new</span> ClassReference.Handle(<span class="string">"java/util/Map"</span>)))) &#123;</span><br><span class="line">                <span class="comment">//如果该类为集合类，则存储的所有元素都是污染</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argTaint.size(); i++) &#123;</span><br><span class="line">                    argTaint.get(<span class="number">0</span>).addAll(argTaint.get(i));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (returnType.getSort() == Type.OBJECT || returnType.getSort() == Type.ARRAY) &#123;</span><br><span class="line">                    resultTaint.addAll(argTaint.get(<span class="number">0</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (retSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            push(resultTaint);<span class="comment">//污染结果入栈</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; retSize; i++) &#123;</span><br><span class="line">                push();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unsupported opcode: "</span> + opcode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后回来看<code>PassthroughDataflowMethodVisitor</code>重载的部分，主要重载了两个函数<code>visitFieldInsn</code>和<code>visitMethodInsn</code></p>
<p>其中做的操作个人看不出太多原委，涉及到很多堆栈之类的，才疏学浅，不过推荐看 <a href="https://xz.aliyun.com/t/7058#toc-3" target="_blank" rel="noopener">https://xz.aliyun.com/t/7058#toc-3</a>  部分的分析，感觉讲的很不错。</p>
<p>通过<code>PassthroughDataflowMethodVisitor</code>就可以获取到所有方法的以及对应污染返回值的参数index信息</p>
<p><img src="https://raw.githubusercontent.com/kingkaki/cloud-img/master/img/20200130213434.png" alt></p>
<h2 id="save-1"><a href="#save-1" class="headerlink" title="save"></a>save</h2><p>也就是按照特定的格式，将passthroughDataflow中的信息保存至passthrough.dat中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (passthroughDataflow == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Save called before discover()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DataLoader.saveData(Paths.get(<span class="string">"passthrough.dat"</span>), <span class="keyword">new</span> PassThroughFactory(), passthroughDataflow.entrySet());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>个人感觉这部分信息应该是污点分析中最重要的一部分信息了，所以中间的处理过程也相对比较复杂<br><code>类名 | 方法名 | 方法描述 | 污点index</code></p>
<h1 id="CallGraphDiscovery"><a href="#CallGraphDiscovery" class="headerlink" title="CallGraphDiscovery"></a>CallGraphDiscovery</h1><p>这里主要是获取各个函数之间的调用关系(Call Graph)，以及调用者与被调用函数之间参数的传递关系</p>
<h2 id="discover-2"><a href="#discover-2" class="headerlink" title="discover"></a>discover</h2><p>一开始还是一样的load之前加载过的信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载所有方法信息</span></span><br><span class="line">Map&lt;MethodReference.Handle, MethodReference&gt; methodMap = DataLoader.loadMethods();</span><br><span class="line"><span class="comment">//加载所有类信息</span></span><br><span class="line">Map&lt;ClassReference.Handle, ClassReference&gt; classMap = DataLoader.loadClasses();</span><br><span class="line"><span class="comment">//加载所有父子类、超类、实现类关系</span></span><br><span class="line">InheritanceMap inheritanceMap = InheritanceMap.load();</span><br><span class="line"><span class="comment">//加载所有方法参数和返回值的污染关联</span></span><br><span class="line">Map&lt;MethodReference.Handle, Set&lt;Integer&gt;&gt; passthroughDataflow = PassthroughDiscovery.load();</span><br></pre></td></tr></table></figure>
<p>然后通过<code>ModelGeneratorClassVisitor</code>来进行类观察，这时候可以注意到多传入了一个<code>serializableDecider</code>序列化决策者，它是一个接口，每个config都有对应的具体实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SerializableDecider serializableDecider = config.getSerializableDecider(methodMap, inheritanceMap);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (ClassResourceEnumerator.ClassResource classResource : classResourceEnumerator.getAllClasses()) &#123;</span><br><span class="line">    <span class="keyword">try</span> (InputStream in = classResource.getInputStream()) &#123;</span><br><span class="line">        ClassReader cr = <span class="keyword">new</span> ClassReader(in);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cr.accept(<span class="keyword">new</span> ModelGeneratorClassVisitor(classMap, inheritanceMap, passthroughDataflow, serializableDecider, Opcodes.ASM6),</span><br><span class="line">                      ClassReader.EXPAND_FRAMES);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            LOGGER.error(<span class="string">"Error analyzing: "</span> + classResource.getName(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ModelGeneratorClassVisitor</code>一开始是简单的记录对应信息，然后在<code>visitMethod</code>时用<code>ModelGeneratorMethodVisitor</code>对方法进行观察</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MethodVisitor <span class="title">visitMethod</span><span class="params">(<span class="keyword">int</span> access, String name, String desc, String signature, String[] exceptions)</span> </span>&#123;</span><br><span class="line">    MethodVisitor mv = <span class="keyword">super</span>.visitMethod(access, name, desc, signature, exceptions);</span><br><span class="line">    ModelGeneratorMethodVisitor modelGeneratorMethodVisitor = <span class="keyword">new</span> ModelGeneratorMethodVisitor(classMap, inheritanceMap, passthroughDataflow, serializableDecider, api, mv, <span class="keyword">this</span>.name, access, name, desc, signature, exceptions);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> JSRInlinerAdapter(modelGeneratorMethodVisitor, access, name, desc, signature, exceptions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ModelGeneratorMethodVisitor</code>主要重写了<code>visitCode</code>、<code>visitFieldInsn</code>、<code>visitMethodInsn</code>三个方法</p>
<p>具体入栈出栈规则确实也能力有限，推荐看 <a href="https://xz.aliyun.com/t/7058#toc-4" target="_blank" rel="noopener">https://xz.aliyun.com/t/7058#toc-4</a> </p>
<p>从而获取到调用函数与被调用函数的参数对应关系</p>
<h2 id="save-2"><a href="#save-2" class="headerlink" title="save"></a>save</h2><p>save的方式也和之前类似，将获取到的<code>discoveredCalls</code>变量以特定格式存储到callgraph.dat中</p>
<p><img src="https://raw.githubusercontent.com/kingkaki/cloud-img/master/img/20200130220001.png" alt></p>
<p>存储的格式为</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">调用者类名 |<span class="string"> 调用者方法 </span>|<span class="string"> 调用者方法描述 </span>|<span class="string"> 被调用者类名 </span>|<span class="string"> 被调用者方法 </span>|<span class="string"> 被调用者方法描述 </span>|<span class="string"> 调用者方法参index </span>|<span class="string"> 调用者字段名 </span>|<span class="string"> 被调用者方法参数索引</span></span><br><span class="line"><span class="string">Main (Ljava/lang/String;)V main A method1 (Ljava/lang/String;)Ljava/lang/String; 1 1</span></span><br></pre></td></tr></table></figure>
<h1 id="SourceDiscovery"><a href="#SourceDiscovery" class="headerlink" title="SourceDiscovery"></a>SourceDiscovery</h1><p>这里的功能就是找到所有的source点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!Files.exists(Paths.get(<span class="string">"sources.dat"</span>))) &#123;</span><br><span class="line">    LOGGER.info(<span class="string">"Discovering gadget chain source methods..."</span>);</span><br><span class="line">    SourceDiscovery sourceDiscovery = config.getSourceDiscovery();</span><br><span class="line">    <span class="comment">//查找利用链的入口（例：java原生反序列化的readObject）</span></span><br><span class="line">    sourceDiscovery.discover();</span><br><span class="line">    sourceDiscovery.save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的SourceDiscovery是个抽象类，会根据config有具体的实现，后面的部分就以jackson的实现为具体例子</p>
<h2 id="discover-3"><a href="#discover-3" class="headerlink" title="discover"></a>discover</h2><p>最开始的discover入口在抽象类中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;ClassReference.Handle, ClassReference&gt; classMap = DataLoader.loadClasses();</span><br><span class="line">Map&lt;MethodReference.Handle, MethodReference&gt; methodMap = DataLoader.loadMethods();</span><br><span class="line">InheritanceMap inheritanceMap = InheritanceMap.load();</span><br><span class="line"></span><br><span class="line">Map&lt;MethodReference.Handle, Set&lt;GraphCall&gt;&gt; graphCallMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (GraphCall graphCall : DataLoader.loadData(Paths.get(<span class="string">"callgraph.dat"</span>), <span class="keyword">new</span> GraphCall.Factory())) &#123;</span><br><span class="line">    MethodReference.Handle caller = graphCall.getCallerMethod();</span><br><span class="line">    <span class="keyword">if</span> (!graphCallMap.containsKey(caller)) &#123;</span><br><span class="line">        Set&lt;GraphCall&gt; graphCalls = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        graphCalls.add(graphCall);</span><br><span class="line">        graphCallMap.put(caller, graphCalls);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        graphCallMap.get(caller).add(graphCall);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">discover(classMap, methodMap, inheritanceMap, graphCallMap);</span><br></pre></td></tr></table></figure>
<p>load了类信息/函数信息/继承信息</p>
<p>然后根据graphCall中的信息，生成了graphCallMap，也就是<code>caller -&gt; set(GraphCall)</code>的信息，然后一同传入实现类的<code>discover</code>方法中</p>
<p>以jackson的实现类为例，可以看到这里将所有的初始化方法，getter和setter方法都设为了source。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> JacksonSerializableDecider serializableDecider = <span class="keyword">new</span> JacksonSerializableDecider(methodMap);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (MethodReference.Handle method : methodMap.keySet()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (serializableDecider.apply(method.getClassReference())) &#123;</span><br><span class="line">        <span class="keyword">if</span> (method.getName().equals(<span class="string">"&lt;init&gt;"</span>) &amp;&amp; method.getDesc().equals(<span class="string">"()V"</span>)) &#123;</span><br><span class="line">            addDiscoveredSource(<span class="keyword">new</span> Source(method, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (method.getName().startsWith(<span class="string">"get"</span>) &amp;&amp; method.getDesc().startsWith(<span class="string">"()"</span>)) &#123;</span><br><span class="line">            addDiscoveredSource(<span class="keyword">new</span> Source(method, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (method.getName().startsWith(<span class="string">"set"</span>) &amp;&amp; method.getDesc().matches(<span class="string">"\\(L[^;]*;\\)V"</span>)) &#123;</span><br><span class="line">            addDiscoveredSource(<span class="keyword">new</span> Source(method, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就获取到了所有的source点</p>
<h2 id="save-3"><a href="#save-3" class="headerlink" title="save"></a>save</h2><p>然后就是将source信息保存到sources.bat中</p>
<p><img src="https://raw.githubusercontent.com/kingkaki/cloud-img/master/img/20200130221308.png" alt></p>
<p>可以看到Source类中不仅记录了方法信息，还有被污染的参数index（当然索引信息对jackson来说应该是用不上的）</p>
<h1 id="GadgetChainDiscovery"><a href="#GadgetChainDiscovery" class="headerlink" title="GadgetChainDiscovery"></a>GadgetChainDiscovery</h1><p>前面都是信息搜集的工作，到这里就是真正的gadget寻找过程了</p>
<p>while前面都是一些准备工作</p>
<p>获取method信息和类继承关系，并获取所有method的继承/实现关系，并保存到<code>methodimpl.dat</code>中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;MethodReference.Handle, MethodReference&gt; methodMap = DataLoader.loadMethods();</span><br><span class="line">InheritanceMap inheritanceMap = InheritanceMap.load();</span><br><span class="line">Map&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; methodImplMap = InheritanceDeriver.getAllMethodImplementations(</span><br><span class="line">    inheritanceMap, methodMap);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> ImplementationFinder implementationFinder = config.getImplementationFinder(</span><br><span class="line">    methodMap, methodImplMap, inheritanceMap);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> (Writer writer = Files.newBufferedWriter(Paths.get(<span class="string">"methodimpl.dat"</span>))) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; entry : methodImplMap.entrySet()) &#123;</span><br><span class="line">        writer.write(entry.getKey().getClassReference().getName());</span><br><span class="line">        writer.write(<span class="string">"\t"</span>);</span><br><span class="line">        writer.write(entry.getKey().getName());</span><br><span class="line">        writer.write(<span class="string">"\t"</span>);</span><br><span class="line">        writer.write(entry.getKey().getDesc());</span><br><span class="line">        writer.write(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="keyword">for</span> (MethodReference.Handle method : entry.getValue()) &#123;</span><br><span class="line">            writer.write(<span class="string">"\t"</span>);</span><br><span class="line">            writer.write(method.getClassReference().getName());</span><br><span class="line">            writer.write(<span class="string">"\t"</span>);</span><br><span class="line">            writer.write(method.getName());</span><br><span class="line">            writer.write(<span class="string">"\t"</span>);</span><br><span class="line">            writer.write(method.getDesc());</span><br><span class="line">            writer.write(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后面是load callgraph，并和之前一样整理到grapCallMap信息</p>
<p>然后加载source信息，初始化gadgetChain（需要注意一下的是<code>GadgetChainLink</code>应该指的是一个node节点，<code>GadgetChain</code>指的是整条gadget链）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;MethodReference.Handle, Set&lt;GraphCall&gt;&gt; graphCallMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (GraphCall graphCall : DataLoader.loadData(Paths.get(<span class="string">"callgraph.dat"</span>), <span class="keyword">new</span> GraphCall.Factory())) &#123;</span><br><span class="line">    MethodReference.Handle caller = graphCall.getCallerMethod();</span><br><span class="line">    <span class="keyword">if</span> (!graphCallMap.containsKey(caller)) &#123;</span><br><span class="line">        Set&lt;GraphCall&gt; graphCalls = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        graphCalls.add(graphCall);</span><br><span class="line">        graphCallMap.put(caller, graphCalls);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        graphCallMap.get(caller).add(graphCall);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Set&lt;GadgetChainLink&gt; exploredMethods = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">LinkedList&lt;GadgetChain&gt; methodsToExplore = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">LinkedList&lt;GadgetChain&gt; methodsToExploreRepeat = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (Source source : DataLoader.loadData(Paths.get(<span class="string">"sources.dat"</span>), <span class="keyword">new</span> Source.Factory())) &#123;</span><br><span class="line">    GadgetChainLink srcLink = <span class="keyword">new</span> GadgetChainLink(source.getSourceMethod(), source.getTaintedArgIndex());</span><br><span class="line">    <span class="keyword">if</span> (exploredMethods.contains(srcLink)) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    methodsToExplore.add(<span class="keyword">new</span> GadgetChain(Arrays.asList(srcLink)));</span><br><span class="line">    exploredMethods.add(srcLink);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>while中的部分就是真正开始找链的部分</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (methodsToExplore.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((iteration % <span class="number">1000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        LOGGER.info(<span class="string">"Iteration "</span> + iteration + <span class="string">", Search space: "</span> + methodsToExplore.size());</span><br><span class="line">    &#125;</span><br><span class="line">    iteration += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    GadgetChain chain = methodsToExplore.pop();</span><br><span class="line">    GadgetChainLink lastLink = chain.links.get(chain.links.size()-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    Set&lt;GraphCall&gt; methodCalls = graphCallMap.get(lastLink.method);</span><br><span class="line">    <span class="keyword">if</span> (methodCalls != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (GraphCall graphCall : methodCalls) &#123;</span><br><span class="line">            <span class="keyword">if</span> (graphCall.getCallerArgIndex() != lastLink.taintedArgIndex) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Set&lt;MethodReference.Handle&gt; allImpls = implementationFinder.getImplementations(graphCall.getTargetMethod());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (MethodReference.Handle methodImpl : allImpls) &#123;</span><br><span class="line">                GadgetChainLink newLink = <span class="keyword">new</span> GadgetChainLink(methodImpl, graphCall.getTargetArgIndex());</span><br><span class="line">                <span class="keyword">if</span> (exploredMethods.contains(newLink)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (chain.links.size() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                        GadgetChain newChain = <span class="keyword">new</span> GadgetChain(chain, newLink);</span><br><span class="line">                        methodsToExploreRepeat.add(newChain);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                GadgetChain newChain = <span class="keyword">new</span> GadgetChain(chain, newLink);</span><br><span class="line">                <span class="keyword">if</span> (isSink(methodImpl, graphCall.getTargetArgIndex(), inheritanceMap)) &#123;</span><br><span class="line">                    <span class="comment">// 到达sink，则表示gadget已找到</span></span><br><span class="line">                    discoveredGadgets.add(newChain);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 否则加入到下一次循环</span></span><br><span class="line">                    methodsToExplore.add(newChain);</span><br><span class="line">                    exploredMethods.add(newLink);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用while循环的目的是因为在寻找的过程中，如果没到达sink，则会将新延长的gadget加入其中，后续继续寻找更长的链（除非改链无法继续延长了，也就是没有多余的CallGraph）</p>
<p>去出带寻找的链，pop出最后一个节点，并获取最后一个节点的所有函数调用（GraphCall）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GadgetChain chain = methodsToExplore.pop();</span><br><span class="line">GadgetChainLink lastLink = chain.links.get(chain.links.size()-<span class="number">1</span>);</span><br><span class="line">Set&lt;GraphCall&gt; methodCalls = graphCallMap.get(lastLink.method);</span><br></pre></td></tr></table></figure>
<p>遍历所有的GraphCall</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (GraphCall graphCall : methodCalls)</span><br></pre></td></tr></table></figure>
<p>如果可控参数位置不对应，则跳过</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (graphCall.getCallerArgIndex() != lastLink.taintedArgIndex) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后获取所有的实现方法（但对应不同的config有不同的实现，例如jackson获取的就不是所有实现方法）</p>
<p>具体逻辑可以跟进到<code>JacksonImplementationFinder</code>的apply</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;MethodReference.Handle&gt; getImplementations(MethodReference.Handle target) &#123;</span><br><span class="line">    Set&lt;MethodReference.Handle&gt; allImpls = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For jackson search, we don't get to specify the class; it uses reflection to instantiate the</span></span><br><span class="line">    <span class="comment">// class itself. So just add the target method if the target class is serializable.</span></span><br><span class="line">    <span class="keyword">if</span> (Boolean.TRUE.equals(serializableDecider.apply(target.getClassReference()))) &#123;</span><br><span class="line">        allImpls.add(target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> allImpls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>JacksonSerializableDecider</code>的<code>apply</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">apply</span><span class="params">(ClassReference.Handle handle)</span> </span>&#123;</span><br><span class="line">    Boolean cached = cache.get(handle);</span><br><span class="line">    <span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cached;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;MethodReference.Handle&gt; classMethods = methodsByClassMap.get(handle);</span><br><span class="line">    <span class="keyword">if</span> (classMethods != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (MethodReference.Handle method : classMethods) &#123;</span><br><span class="line">            <span class="comment">//该类，只要有无参构造方法，就通过决策</span></span><br><span class="line">            <span class="keyword">if</span> (method.getName().equals(<span class="string">"&lt;init&gt;"</span>) &amp;&amp; method.getDesc().equals(<span class="string">"()V"</span>)) &#123;</span><br><span class="line">                cache.put(handle, Boolean.TRUE);</span><br><span class="line">                <span class="keyword">return</span> Boolean.TRUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cache.put(handle, Boolean.FALSE);</span><br><span class="line">    <span class="keyword">return</span> Boolean.FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到作者也解释了对于jackson来说只要有构造方法则通过决策，返回当前类。（为啥没有父类？）</p>
<p>而javaserial的<code>getImplementations</code>中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Set&lt;MethodReference.Handle&gt; getImplementations(MethodReference.Handle target) &#123;</span><br><span class="line">    Set&lt;MethodReference.Handle&gt; allImpls = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assume that the target method is always available, even if not serializable; the target may just be a local</span></span><br><span class="line">    <span class="comment">// instance rather than something an attacker can control.</span></span><br><span class="line">    allImpls.add(target);</span><br><span class="line"></span><br><span class="line">    Set&lt;MethodReference.Handle&gt; subClassImpls = methodImplMap.get(target);</span><br><span class="line">    <span class="keyword">if</span> (subClassImpls != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (MethodReference.Handle subClassImpl : subClassImpls) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Boolean.TRUE.equals(serializableDecider.apply(subClassImpl.getClassReference()))) &#123;</span><br><span class="line">                allImpls.add(subClassImpl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> allImpls;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Boolean <span class="title">apply</span><span class="params">(ClassReference.Handle handle)</span> </span>&#123;</span><br><span class="line">    Boolean cached = cache.get(handle);</span><br><span class="line">    <span class="keyword">if</span> (cached != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cached;</span><br><span class="line">    &#125;</span><br><span class="line">    Boolean result = applyNoCache(handle);</span><br><span class="line">    cache.put(handle, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Boolean <span class="title">applyNoCache</span><span class="params">(ClassReference.Handle handle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isBlacklistedClass(handle)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否有直接或间接实现java/io/Serializable序列化接口</span></span><br><span class="line">    <span class="keyword">if</span> (inheritanceMap.isSubclassOf(handle, <span class="keyword">new</span> ClassReference.Handle(<span class="string">"java/io/Serializable"</span>))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要就是判断包括当前类在内的所有父类/实现类是否实现了<code>Serializable</code>(也就是是否可实例化)，然后将包括当前方法在内的实现方法返回。</p>
<p>然后对于所有符合要求的<code>methodImpl</code>进行遍历</p>
<p>判断是否被访问过的节点，避免死循环</p>
<p>其实个人感觉这里判断的方式其实有点问题，单纯的用<code>exploredMethods.contains</code>来判断总感觉不大合理，总感觉是应该判断gadget的链路上是否包含<code>newLink</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GadgetChainLink newLink = <span class="keyword">new</span> GadgetChainLink(methodImpl, graphCall.getTargetArgIndex());</span><br><span class="line"><span class="keyword">if</span> (exploredMethods.contains(newLink)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (chain.links.size() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        GadgetChain newChain = <span class="keyword">new</span> GadgetChain(chain, newLink);</span><br><span class="line">        methodsToExploreRepeat.add(newChain);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后判断是否到达了sink点，到了则加入<code>discoveredGadgets</code>中，否则相当于延长了链路，则添加到<code>exploredMethods</code>中，等待下一次寻找新的延申节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GadgetChain newChain = <span class="keyword">new</span> GadgetChain(chain, newLink);</span><br><span class="line"><span class="keyword">if</span> (isSink(methodImpl, graphCall.getTargetArgIndex(), inheritanceMap)) &#123;</span><br><span class="line">    <span class="comment">// 到达sink，则表示gadget已找到</span></span><br><span class="line">    discoveredGadgets.add(newChain);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 否则加入到下一次循环</span></span><br><span class="line">    methodsToExplore.add(newChain);</span><br><span class="line">    exploredMethods.add(newLink);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的判断是否是Sink的函数也可以跟进看下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSink</span><span class="params">(MethodReference.Handle method, <span class="keyword">int</span> argIndex, InheritanceMap inheritanceMap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (GadgetInspector.giConfig.getName().equals(<span class="string">"sqlinject"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> isSQLInjectSink(method, argIndex, inheritanceMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">"java/io/FileInputStream"</span>)</span><br><span class="line">        &amp;&amp; method.getName().equals(<span class="string">"&lt;init&gt;"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">"java/io/FileOutputStream"</span>)</span><br><span class="line">        &amp;&amp; method.getName().equals(<span class="string">"&lt;init&gt;"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">"java/nio/file/Files"</span>)</span><br><span class="line">        &amp;&amp; (method.getName().equals(<span class="string">"newInputStream"</span>)</span><br><span class="line">            || method.getName().equals(<span class="string">"newOutputStream"</span>)</span><br><span class="line">            || method.getName().equals(<span class="string">"newBufferedReader"</span>)</span><br><span class="line">            || method.getName().equals(<span class="string">"newBufferedWriter"</span>))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">"java/lang/Runtime"</span>)</span><br><span class="line">        &amp;&amp; method.getName().equals(<span class="string">"exec"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        if (method.getClassReference().getName().equals("java/lang/Class")</span></span><br><span class="line"><span class="comment">                &amp;&amp; method.getName().equals("forName")) &#123;</span></span><br><span class="line"><span class="comment">            return true;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        if (method.getClassReference().getName().equals("java/lang/Class")</span></span><br><span class="line"><span class="comment">                &amp;&amp; method.getName().equals("getMethod")) &#123;</span></span><br><span class="line"><span class="comment">            return true;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    <span class="comment">// If we can invoke an arbitrary method, that's probably interesting (though this doesn't assert that we</span></span><br><span class="line">    <span class="comment">// can control its arguments). Conversely, if we can control the arguments to an invocation but not what</span></span><br><span class="line">    <span class="comment">// method is being invoked, we don't mark that as interesting.</span></span><br><span class="line">    <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">"java/lang/reflect/Method"</span>)</span><br><span class="line">        &amp;&amp; method.getName().equals(<span class="string">"invoke"</span>) &amp;&amp; argIndex == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">"java/net/URLClassLoader"</span>)</span><br><span class="line">        &amp;&amp; method.getName().equals(<span class="string">"newInstance"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">"java/lang/System"</span>)</span><br><span class="line">        &amp;&amp; method.getName().equals(<span class="string">"exit"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">"java/lang/Shutdown"</span>)</span><br><span class="line">        &amp;&amp; method.getName().equals(<span class="string">"exit"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">"java/lang/Runtime"</span>)</span><br><span class="line">        &amp;&amp; method.getName().equals(<span class="string">"exit"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">"java/nio/file/Files"</span>)</span><br><span class="line">        &amp;&amp; method.getName().equals(<span class="string">"newOutputStream"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">"java/lang/ProcessBuilder"</span>)</span><br><span class="line">        &amp;&amp; method.getName().equals(<span class="string">"&lt;init&gt;"</span>) &amp;&amp; argIndex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inheritanceMap.isSubclassOf(method.getClassReference(), <span class="keyword">new</span> ClassReference.Handle(<span class="string">"java/lang/ClassLoader"</span>))</span><br><span class="line">        &amp;&amp; method.getName().equals(<span class="string">"&lt;init&gt;"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">"java/net/URL"</span>) &amp;&amp; method.getName().equals(<span class="string">"openStream"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Some groovy-specific sinks</span></span><br><span class="line">    <span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">"org/codehaus/groovy/runtime/InvokerHelper"</span>)</span><br><span class="line">        &amp;&amp; method.getName().equals(<span class="string">"invokeMethod"</span>) &amp;&amp; argIndex == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inheritanceMap.isSubclassOf(method.getClassReference(), <span class="keyword">new</span> ClassReference.Handle(<span class="string">"groovy/lang/MetaClass"</span>))</span><br><span class="line">        &amp;&amp; Arrays.asList(<span class="string">"invokeMethod"</span>, <span class="string">"invokeConstructor"</span>, <span class="string">"invokeStaticMethod"</span>).contains(method.getName())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((inheritanceMap.isSubclassOf(method.getClassReference(), <span class="keyword">new</span> ClassReference.Handle(<span class="string">"java/rmi/registry/Registry"</span>)) ||</span><br><span class="line">         inheritanceMap.isSubclassOf(method.getClassReference(), <span class="keyword">new</span> ClassReference.Handle(<span class="string">"javax/naming/Context"</span>)))</span><br><span class="line">        &amp;&amp; method.getName().equals(<span class="string">"lookup"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一种不太优雅的白名单方式来判断sink。</p>
<p>然后不断地遍历，直至所有未到sink的gadget没有非重复延伸节点为止（通俗说也就是遍历完了所有可能的路径）</p>
<h1 id="一些思考"><a href="#一些思考" class="headerlink" title="一些思考"></a>一些思考</h1><p>gadgetinspector的分析是建立在ASM级别的字节码操作上的，对于新人来说其实有些不友好，需要比较多的Java字节码和内存结构的一些知识，相较Soot而言，Soot提供了一种更高层次的抽象，操作起来其实会很舒服（但由于更新不及时对于一些新版本的字节码解析能力差得一批，而且可扩展性自然也没ASM那么好）</p>
<p>由于字节码操作部分的不是很熟悉，具体的操作流程也没有太仔细看，但是貌似加入了控制流图之类的操作（这样的话会比我想象的做的工作要多很多）。至于一些操作上的内存浪费，无缓存，重复工作之类小槽点也不吐槽了，还有一些查找策略的小问题，会导致有一些漏报，在搜索时候的避免死循环的决策导致的，个人感觉那里的判断应该改为<code>if (chain.links.contains(newLink))</code>，只要判断当前链上是否有过改节点即可。还有jackson没扫描实现方法的问题。seebug那篇中说还有callgraph生成不完全的问题，不知道是不是因为控制流之类的原因，具体的实现过程我也没仔细跟了。</p>
<p>总体评价这个程序的话个人感觉学习的意义大于实战的，由于是基于数据流的，一些污点传递函数就需要不断拓展，否则污点信息会比较容跟丢，这就让我想到了去年下半年在freebuf上看到的基于抽象语法树的gadget寻找工具 <a href="https://www.freebuf.com/articles/web/213327.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/web/213327.html</a>  里面做的工作其实很少，只是单纯的对sink点进行暴力搜索，没有什么实现类的处理和数据流的分析（个人之前自己做的时候发现实现类这种东西确实蛮重要的，尤其是interface，不找到实现类，这个接口是毫无意义的），但是反观下来，这里挖掘的gadget似乎效果更佳明显，编码工作量也没那么大，加一些人工操作之后感觉会更适合实际挖掘。</p>
<p>总之对于实现继承类的处理，和拓扑排序之类的操作确实是可以学习和借鉴的。对于一些自动化审计的工作有一些参考意义。</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p> <a href="https://xz.aliyun.com/t/7058" target="_blank" rel="noopener">https://xz.aliyun.com/t/7058</a> </p>
<p> <a href="https://paper.seebug.org/1034/" target="_blank" rel="noopener">https://paper.seebug.org/1034/</a> </p>
<p><a href="https://github.com/JackOfMostTrades/gadgetinspector" target="_blank" rel="noopener">https://github.com/JackOfMostTrades/gadgetinspector</a></p>
<p> <a href="https://github.com/threedr3am/gadgetinspector" target="_blank" rel="noopener">https://github.com/threedr3am/gadgetinspector</a> </p>
<p> <a href="https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;mid=2651750626&amp;idx=1&amp;sn=3e1ac6c41d6e1803abb32285daf0244a&amp;chksm=bd1259af8a65d0b97809a6a8ff5afaff1be4a4232bd8527ef9d95bb7a2e768bd7d9fdc768211&amp;scene=27#wechat_redirect" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MjM5NjQ5MTI5OA==&amp;mid=2651750626&amp;idx=1&amp;sn=3e1ac6c41d6e1803abb32285daf0244a&amp;chksm=bd1259af8a65d0b97809a6a8ff5afaff1be4a4232bd8527ef9d95bb7a2e768bd7d9fdc768211&amp;scene=27#wechat_redirect</a> </p>


                <hr>

                

                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/2020/02/ysoserial-payload分析/" data-toggle="tooltip" data-placement="top" title="ysoserial payload分析">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/2020/01/从源码层面看XXE的防御/" data-toggle="tooltip" data-placement="top" title="从源码层面看XXE的防御">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                

                

            </div>
    <!-- Side Catalog Container -->
        

    <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#java" title="java">java</a>
                        
                          <a class="tag" href="/tags/#语法分析" title="语法分析">语法分析</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">

                    
                        <li><a href="//98587329.github.io" target="_blank">mt</a></li>
                    
                        <li><a href="//www.cflowerth.com" target="_blank">FAtwAER</a></li>
                    
                        <li><a href="//lufe1.cn" target="_blank">lufei</a></li>
                    
                        <li><a href="//0x3f97.github.io" target="_blank">gd</a></li>
                    
                        <li><a href="http://www.lsafe.org" target="_blank">4dmin$5</a></li>
                    
                        <li><a href="http://www.thekingofnight.com/" target="_blank">theKingOfNight</a></li>
                    
                        <li><a href="http://www.thekingofnight.com/" target="_blank">Hpdoger</a></li>
                    
                        <li><a href="//mochazz.github.io/" target="_blank">七月火</a></li>
                    
                        <li><a href="https://mengsec.com/" target="_blank">蒙尘</a></li>
                    
                        <li><a href="https://patrilic.top/" target="_blank">Patrilic</a></li>
                    
                        <li><a href="https://threedr3am.github.io/" target="_blank">threedr3am</a></li>
                    
                        <li><a href="http://rui0.cn/" target="_blank">Ruilin</a></li>
                    
                        <li><a href="https://zgao.top/" target="_blank">zgao</a></li>
                    
                        <li><a href="https://www.zfjsec.com/" target="_blank">zfjsec</a></li>
                    
                </ul>
                
            </div>

        </div>
    </div>
</article>







<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'always',
          placement: 'right',
          icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                

                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/kingkaki">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Kingkk&#39;s Blog 2022 
                    浙ICP备17041487号
                    <br>
                    Theme by <a href="http://huangxuan.me">Hux</a> 
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                    Ported by <a href="http://blog.kaijun.rocks">Kaijun</a>

                    <!-- | 
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=kaijun&repo=hexo-theme-huxblog&type=star&count=true" >
                    </iframe>
                    -->
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("https://www.kingkk/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->




<!-- Baidu Tongji -->

<script>
    // dynamic User by Hux
    var _baId = '2095437387a20021fd7e176e0c1aac8b';

    // Originial
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?" + _baId;
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
</script>


<!-- Side Catalog -->





<!-- Image to hack wechat -->
<img src="https://www.kingkk/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
